# 하나의 퀸이 배치되어 있다고 가정할 때
# 다른 퀸이 놓일 수 없는 칸의 수는 n-1(행) + n-1(열) +  앞의 퀸이 놓인 위치의 대각선 칸들-1 (n-1)이다.
# 총 3 * (n-1)개의 칸에 다른 퀸은 놓일 수 없다.
# 그러면 n*n 체스판에서 다른 퀸이 놓일 수 있는 위치는 n**2 - 3(n-1)(행/열/대각) - 1(첫번째 퀸 위치)개이다.
# 즉 n**2 - 3*n + 2개이다.

# 그리고 n*n 체스판에서 두 퀸을 조건에 맞게 놓을 때 n*n 체스판이 (n-1)*(n-1) 체스판에 행 열 각각 n개씩의 칸이(총 2n-1개) 추가된다는 점을 고려해
# (n-1)*(n-1) 체스판에서의 경우의 수에 추가된 칸들에 퀸을 배치할 때의 경우의 수를 더하는 방식으로 점화식을 작성했다.

# 점화식 : sol(n) = sol(n-1) + 1번[ (2n-1) * (n**2 - 3*n + 2) ] - 2번[ (n-1) * (n-2) ]
# 1번 : 새로 생긴 행, 열의 개수(2n-1)에 퀸을 놓았을 때 다른 퀸을 배치할 수 있는 경우의 수 (n**2 - 3*n + 2) 곱하기 
# 2번 : 새로 생긴 행, 열에 두개의 퀸이 놓인다면 중복된 경우의 수가 발생하기 때문에 중복된 경우의 수 (n-1) * (n-2) 빼주기
# 앞의 점화식을 토대로 재귀하는 함수를 작성했다.

# 시간복잡도 : O(n)
# 시간복잡도의 경우 한번 함수를 호출했을 때 n번 반복하며 알맞은 값을 DP 테이블에 추가하기 때문에 O(n)이다.

def solution(n):
    cnt= 1 # while 반복문을 위한 count 변수

    while cnt < n: #O(n)
        tmp = cnt +1
        next = (2*tmp - 1)*(tmp**2 - 3*tmp + 2) - (tmp-1)*(tmp-2) # sol(n-1)에 더해질 값
        DP.append(DP[-1] + next) # DP 테이블에 저장
        
        cnt +=1

# main
n = int(input())
DP = [0] # DP memoization
solution(n)
print(DP[-1])

